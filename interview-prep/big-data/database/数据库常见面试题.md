# 数据库
### 1. 数据库中的事务是什么，MySQL中是怎么实现的
数据库中的事务是一个不可分割的工作单元，它必须满足 ACID 特性（原子性、一致性、隔离性、持久性），保证一系列操作要么全部成功，要么全部失败，从而确保数据从一种一致状态安全地转换到另一种一致状态。
在 MySQL 中，这主要通过 InnoDB 存储引擎来实现：
其持久性依靠 redo log（重做日志，先写日志后写磁盘，保证 crash-safe）；
原子性和隔离性的核心是 undo log（回滚日志）和多版本并发控制（MVCC）（通过创建数据快照避免读写冲突）；
而一致性则通过前述机制（原子性、隔离性、持久性）的共同保障以及数据库本身的约束（如主键、外键）来实现。
___
### 2. MySQL事务的特性?
MySQL 事务必须具备 ACID 四大特性：原子性（Atomicity） 保证事务内的操作要么全部成功，要么全部失败回滚；一致性（Consistency） 确保事务执行后数据库从一个一致状态变换到另一个一致状态，遵循所有约束规则；隔离性（Isolation） 控制并发事务间的相互影响，防止数据混乱；持久性（Durability） 保证事务提交后对数据的修改永久保存，即使系统故障也不会丢失。这些特性共同保障了数据库操作的可靠性和安全性。
___
### 3. 数据库事务的隔离级别?解决了什么问题?默认事务隔离级别?
数据库事务的隔离级别（读未提交、读已提交、可重复读、串行化）定义了并发事务之间的可见性规则，主要用于解决多个事务同时执行时可能导致的脏读、不可重复读和幻读问题；MySQL 的 InnoDB 存储引擎默认隔离级别是可重复读（Repeatable Read），它通过 MVCC（多版本并发控制） 和 间隙锁（Gap Lock） 机制避免了脏读和不可重复读，并一定程度上解决了幻读问题。
___
### 4. 脏读，幻读，不可重复读的定义
脏读是指一个事务读到了另一个未提交事务修改的数据，若对方回滚则读到的是无效数据；不可重复读是指一个事务内两次读取同一行数据，结果不一致（ due to 其他事务修改了该行数据并提交）；幻读是指一个事务内两次按相同条件查询，检索到的行数不一致（ due to 其他事务新增或删除了符合条件的行并提交）。三者均是并发事务下数据读取的一致性问题和隔离性缺陷。
___
### 5. MySQL怎么实现可重复读?
MySQL 的可重复读（Repeatable Read） 隔离级别主要通过 多版本并发控制（MVCC） 机制实现：在事务启动时，InnoDB 会为该事务生成一个一致性读视图（ReadView），该视图决定了事务能看到哪个版本的数据；在事务执行期间，所有普通 SELECT 查询都会基于这个视图读取已经存在的旧数据版本（通过 undo log 构建），而非当前最新的数据，从而确保在同一事务内多次读取同一数据时，结果始终一致，避免了不可重复读问题。
<br><br>MVCC多版本并发控制：空间增长与负载相关：写操作越频繁（尤其是更新和删除），产生的旧版本数据就越多，UNDO LOG 体积增长越快。
但是占用是一时的，有定期的purge线程，它会定期清理那些不再被任何活跃事务需要的旧版本数据，从而回收空间。如果旧版本数据因为长事务的存在而无法被及时清理，才会导致空间过度膨胀，这才是需要避免的情况。

___
### 6. 数据库第三范式和第四范式区别?
数据库第三范式（3NF） 要求数据表中不存在非主键列对其它非主键列的传递依赖（即每个非主属性都直接依赖于主键），其核心是消除冗余数据；而第四范式（4NF） 在满足3NF的基础上，进一步要求消除多值依赖（即一个字段包含多个值，且这些值与其他字段存在独立关系），其核心是将多值属性分离到新表中，确保数据关系的原子性。简单来说，3NF解决数据冗余问题，4NF解决属性间一对多关系的结构问题。
<br>第一范式（1NF） 是数据库设计的基石，它要求表中的每个列（字段）都是原子的，即不可再分。<br>
第二范式（2NF） 在满足1NF的基础上，进一步要求表中的所有非主键字段必须完全依赖于整个主键，而不能只依赖于主键的一部分。<br>
第三范式（3NF） 在满足2NF的基础上，要求消除传递依赖，即任何非主键字段之间不能存在依赖关系，它们都必须只依赖于主键<br>
第四范式（4NF） 在满足3NF的基础上，处理更特殊的多值依赖问题。它要求一个表中不能存在两个或多个相互独立的多值属性。
___
### 7. MySQL的存储引擎?
MySQL 采用插件式存储引擎架构，其中 InnoDB 是默认且最核心的引擎，支持事务、行级锁、外键等关键特性，适用于绝大多数需要高并发和数据一致性的场景；MyISAM 是早期默认引擎，仅支持表级锁和全文索引，但不支持事务，适用于读多写少的静态数据查询；Memory 引擎将数据完全存储在内存中，速度极快但重启后数据丢失，适合临时表或缓存。此外，MySQL 还支持 Archive（高压缩比归档）、CSV（以文本文件存储）等专用引擎，用户可根据数据一致性、性能和应用场景需求灵活选择。
___
### 8. 数据库有哪些锁?
- 数据库锁按粒度可分为行级锁（锁定单行，并发高但开销大）、表级锁（锁定整表，开销小但并发低）和页级锁（折中方案）；
- 按操作类型可分为共享锁（S锁）（允许读禁止写）和排他锁（X锁）（禁止其他任何操作）；
- 按兼容性可分为乐观锁（通过版本号等机制避免冲突）和悲观锁（默认冲突发生，先加锁再操作）。
- 此外还有意向锁（快速判断表是否被加锁）、间隙锁（防止幻读）等特殊锁机制，共同保障并发事务的数据一致性。
___
### 9. 说下悲观锁、乐观锁
悲观锁是一种“先取锁，再访问” 的保守并发控制策略。它假定并发冲突很可能发生，因此在操作数据之前会先加锁（如行锁、表锁），确保在整个操作过程中数据不会被其他事务修改。这种机制通过数据库原生锁（如 SELECT ... FOR UPDATE）实现，保证了数据的强一致性，但会降低系统吞吐量，适用于写操作频繁、冲突概率高的场景。

乐观锁是一种“先访问，后检测” 的乐观并发控制策略。它假定并发冲突很少发生，因此不会直接加锁，而是在提交更新时检测数据是否被其他事务修改过。通常通过版本号（version）或时间戳字段实现：读取数据时记录版本号，更新时校验版本号是否变化，若变化则拒绝更新并抛出异常。这种机制通过应用程序逻辑实现，提高了系统吞吐量，但需要处理更新失败的重试逻辑，适用于读多写少、冲突概率低的场景。
___
### 10. 分布式数据库是什么?
分布式数据库是一种将数据存储、管理和处理分散在多个物理节点（计算机或服务器）上的数据库系统，这些节点通过网络连接协同工作，对外提供一个逻辑上的统一数据库视图；它通过数据分片（Sharding） 将大数据集水平拆分到不同节点，利用多副本（Replication） 机制实现高可用和容错，并通过分布式事务协议（如两阶段提交）保障跨节点数据的一致性，从而突破单机数据库在存储容量、处理性能和可靠性上的瓶颈，满足海量数据、高并发访问和全球化部署的业务需求。
___
### 11. 死锁产生的条件是什么?如何预防死锁?
死锁产生的四个必要条件是：

互斥条件（资源同一时间只能被一个进程占用）、请求与保持条件（进程在持有资源的同时请求新资源）、不可剥夺条件（资源只能由持有者主动释放）和循环等待条件（多个进程形成头尾相接的资源请求环）；

预防死锁的核心是破坏其中任意一个条件，具体方法包括：一次性申请所有资源（破坏请求与保持）、资源分层分配（破坏循环等待）、允许资源抢占（破坏不可剥夺）以及使用超时机制或死锁检测算法（如银行家算法）来主动避免或解除死锁状态。
___
### 12. 介绍下数据库的ioin(内连接，外连接，全连接)，内连接和外连接(左，右连接)的区别
数据库连接（JOIN）用于合并多张表的记录，主要分为：内连接（INNER JOIN） 仅返回两表中匹配条件的记录；

外连接包括左外连接（LEFT JOIN）（返回左表全部记录及右表匹配记录，右表无匹配则补空）、右外连接（RIGHT JOIN）（返回右表全部记录及左表匹配记录，左表无匹配则补空）和全外连接（FULL JOIN）（返回左右表所有记录，无匹配均补空）；

核心区别在于内连接注重交集，而外连接保留单表或双表全部数据（左/右连接保留指定方向表的全部数据），适用于需展示主表完整信息及关联表可选信息的场景。
___
### 13. MySQL的join过程
MySQL 的 JOIN 过程核心是对多张表根据关联条件进行匹配和组合。其最基础且常用的算法是 Nested-Loop Join（嵌套循环连接），它通过双重循环实现：首先遍历驱动表（通常是小表或经过筛选的表）的每一行，然后对于每一行，遍历被驱动表的所有行并检查关联条件（如 ON t1.id = t2.id）是否满足，若满足则组合成结果集的一行。

为提升性能，MySQL 会利用索引来加速循环：理想情况下会在被驱动表的关联字段上建立索引，这样内层循环无需全表扫描，可快速定位匹配行，这种优化称为 Index Nested-Loop Join。若无可用索引，则需扫描整个被驱动表，效率低下，称为 Simple Nested-Loop Join。

对于大数据集，MySQL 可能采用更复杂的 Block Nested-Loop Join 算法：先将驱动表的多行读入连接缓冲区（Join Buffer），再批量与被驱动表比较，通过减少内层表的扫描次数来降低 I/O 开销。整个过程由优化器选择最高效的执行计划，确保联接操作性能最优
___
### 14. MySQL有哪些存储引擎?
MySQL 采用插件式存储引擎架构，其中 InnoDB 是默认且最核心的引擎，支持事务、行级锁、外键等关键特性，适用于绝大多数需要高并发和数据一致性的场景；MyISAM 是早期默认引擎，仅支持表级锁和全文索引，但不支持事务，适用于读多写少的静态数据查询；Memory 引擎将数据完全存储在内存中，速度极快但重启后数据丢失，适合临时表或缓存。此外，MySQL 还支持 Archive（高压缩比归档）、CSV（以文本文件存储）等专用引擎，用户可根据数据一致性、性能和应用场景需求灵活选择。
1. InnoDB：默认与核心引擎
InnoDB 是 MySQL 5.5 版本之后的默认存储引擎。它最重要的特点是提供了对事务（ACID）、行级锁和外键约束的完整支持。其设计目标就是处理大量短期事务和高并发读写负载，通过多版本并发控制（MVCC） 来实现非阻塞读和高并发性，是绝大多数需要数据完整性和高性能的应用的首选。

2. MyISAM：曾经的王者
MyISAM 是 MySQL 5.5 之前版本的默认引擎。它不支持事务和外键，只提供表级锁。其优势在于访问速度快，尤其适合执行大量的SELECT查询操作，并且支持全文索引（FULLTEXT）。但由于其锁的粒度大，在并发写操作多的情况下性能较差，且发生崩溃后数据恢复能力弱，现在已不推荐用于核心业务表。

3. Memory：极速的内存引擎
Memory 引擎（也称 HEAP）将所有数据都存储在内存中，因此读写速度极快。它通常用于充当临时表或缓存中间结果集，以加速查询。但其最大缺点是：服务器重启或崩溃后，所有数据都会丢失。并且它使用表级锁，只适用于低并发的临时场景。

4. 其他专用引擎
MySQL 还提供了一些针对特殊场景的引擎。例如：

Archive：仅支持插入和查询，不支持删除和更新。它会高密度压缩存储数据，非常适合存储日志、审计等归档数据。

CSV：它的表实际上是一个文本文件，以逗号分隔值格式存储数据，可以与 CSV 格式的文件直接交换数据，常用于数据交换和导入导出。

Blackhole：像“黑洞”一样，接受数据但不存储，任何写入的数据都会消失。主要用于复制架构中，将数据中继到从库。
___
### 15. 数据库中存储引擎MvlSAM与InnoDB的区别
MyISAM 与 InnoDB 的核心区别在于：MyISAM 不支持事务和外键，仅提供表级锁，访问速度快且支持全文索引，适用于读多写少的静态查询场景；而 InnoDB 支持事务、行级锁和外键约束，具备崩溃恢复能力，适用于需要高并发、数据一致性及事务支持的OLTP应用，是MySQL默认的存储引擎。
___
### 16. Mylsam适用于什么场景?
MyISAM 适用于读频率远高于写频率、且无事务要求的静态数据查询场景，例如数据仓库、日志分析、网页内容管理等读密集型应用，因其支持全文索引且访问速度快；但由于其仅提供表级锁且不支持事务，在高并发写入或需要数据强一致性的场景下性能较差且存在风险。
___
### 17. InnoDB和Mvlsam针对读写场景?
InnoDB 为高并发读写和事务安全场景设计（如电商、交易系统），而 MyISAM 仅适用于读远多于写且无事务要求的静态数据场景（如日志分析、内容管理）。
___
### 18. MySQL Innodb实现了哪个隔离级别?
MySQL InnoDB 存储引擎默认且完全实现了“可重复读（Repeatable Read）”隔离级别：它通过多版本并发控制（MVCC） 机制为每个事务创建一致性读视图（Read View），确保事务内多次读取同一数据时结果一致，避免了脏读和不可重复读；同时，通过间隙锁（Gap Lock） 和临键锁（Next-Key Lock） 的组合使用，有效防止了幻读现象，从而在标准 SQL 隔离级别基础上提供了更高级别的数据一致性保证。
___
### 19. InnoDB数据引擎的特点
___
20. InnoDB用什么索引
___
21. Hash索引缺点
___
22. 数据库索引的类型，各有什么优缺点?
___
23. MySQL的索引有哪些?索引如何优化?
___
24. 有哪些数据结构可以作为索引呢?
___
25. B树与B+树的区别?
___
26. 为什么使用B+树作为索引结构?
___
27. 不使用B+树，可以用那个数据类型实现一个索引结构
___
28. 介绍下MySQL的联合索引联合索使用原则
___
29. 数据库有必要建索引吗?
___
30. MySQL缺点?
___
31. 什么是脏读?怎么解决?
___
32. 为什么要有三大范式，建数据库时一定要遵循吗?
___
33. 数据库一般对哪些列建立索引?索引的数据结构?
___
34. MySOL中索引的建立需要考虑哪些问题
___
35. 关系型数据库与非关系型数据库区别
___
36. MySQL与Redis区别
___
37. 列式数据库和行式数据库优劣比对
___
38. 除了UTF-8还有什么编码格式
___
39. 布隆过滤器的基本原理是什么？局限性是什么？使用什么方法可以增加删除的功能？
___
40. 你在哪些场景下使用了布隆过滤器？
___
41. SQL慢查询的解决方案（优化）？
___
42. 聚簇索引、非聚簇索引说一下
___
43. 哈希索引和B+相比的优势和劣势？
___
44. MVCC知道吗？
___
